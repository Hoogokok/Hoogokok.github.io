
---

layout: post

title: ACID(원자성, 일관성, 고립성, 지속성)

date: 2024-10-19

categories: 데이터베이스

---
#ACID #데이터베이스 

### 트랜잭션이란?

* SQL 쿼리의 모음
* 하나의 작업 단위- SQL 쿼리의 특성 테이블이 구조화되어 있단 걸 떠올려보자
*  계좌 입금 (SELECT UPDATE UPDATE) 


#### 트랜잭션의 생명주기

* Transaction BEGIN - 트랜잭션 시작
* Transaction COMMIT - 실제 디스크에 저장해라
* Transaction ROLLBACK - 모든 변경사항을 되돌리기 
	* 롤백을 위한 저장공간이 따로 있다.
	* 만약 20000개의 쿼리를 한번에 커밋하다가 다운되면 롤백해야함

각 데이터베이스에 따라 커밋 정책에 대한 구현이 다르다. 커밋을  곧장 실행시킬 수 도 있고 메모리에 저장하고 나서 한 번에 커밋할 수 도 있다. 이에 따라 롤백이 매우 느리고 힘들 수 있고 아닐 수 도 있다.

### 트랜잭션의 본질

* 대부분 트랜잭션을 데이터를 수정하거나 바꿀 때 사용한다고 생각한다.
* 실제로는 읽기 전용 트랜잭션을 가질 수 있다.
* 사용자가 지정할 수 도 있고 시스템에 의해 암시적으로 정의된 트랜잭션일 수 도 있다.

읽기 전용 트랜잭션은 왜 필요할까?  가령 우리가 어떤 트랜잭션을 실행한 시점에 어떤 정보를 읽어올 때 다른 트랜잭션에서 이를 변경한다고 가정해보자. 이때 고립성의 특성으로 우리는 변경이 가해지지 않은 데이터를 읽어올 수 있다. 이는 뒤에서 고립성 설명에 더 자세히 살펴보자.


### Atomicity 원자성

* 트랜잭션 안의 모든 쿼리는 반드시 성공해야 한다.
* 원자는 더 이상 나뉘어 지지 않음을 은유한다. 따라서 트랜잭션 안의 하나의 쿼리라도 실패한다면 모든 쿼리는 롤백되어야 한다.
* 만약 커밋되기 전의 트랜잭션이 성공했다 하더라도 데이터베이스가 다운되었다면 롤백되어야 한다.
* 다만 어떤 데이터베이스는 커밋 하가 전에도 모든 변경사항을 디스크에 기록하기도 한다. 이를 낙관적 접근이라고 한다. 어떤 데이터베이스는 메모리에 기록해두고 실제 커밋을 보낼 때만 변경사항을 디스크에 저장한다.

### Isolation 고립성

#### Read phenomena 읽기 현상

* 더러운 읽기 dirty reads 다른 트랜잭션이 쓴 내용은 읽지만 실제로 아직 커밋되지 않는 것을 읽는 것
* 중복되지 않는 읽기 Non-repeatable reads는 트랜잭션 중에 단일 레코드 값을 읽은 후, 동일한 트랜잭션에서 값을 한 번 더 읽었을 때 그 값이 변경되는 경우을 말한다. 트랜잭션이 반복되지 않는 걸 의미한다
	* 이를 해결하는 방식은 데이터베이스마다 차이가 있다. 가령 Postgrsql의 경우 행이 업데이트 될때마다, 기존 행은 유지되고 새 행을 만들어 변경되지 않는 값을 복사하고 새 값을 만든다.
	* Mysql의 경우 UNDO 라는 로그에 기존 값을 옮기고 원본 행에 업데이트를 실행한다.
	* 이런 차이로 Postgresql의 경우 원본을 읽기 쉽다. 기존 원본 행이 있기 때문이다.
	* MySql의 경우는 UNDO 로그을 읽는 처리를 따로 해야 한다.
	* 반대로 Posrgresql의 경우 매 업데이트 마다 새행을 발행하기에 메모리를 많이 사용하고 더 이상 유지할 필요가 없는 행의 정리하는 VACCUM을 따로 해야 한다. 
* 유령 읽기 Phanthom reads는 아직 존재하지 않아서 실제로 읽을 수 없는 걸 말한다. 가령 한 트랜잭션에서 특정 범위를 두고 집계를 실행했다고 하자. 처음 실행할 때는 100이었지만 다른 트랜잭션에서 이 특정 범위 안에 정보에 값이 추가되거나 삭제될 때 집계 결과는 달라지게 될것이다. 이처럼 같은 트랜잭션 안에 쿼리 결과의 집합이 변화할 때 이를 Phanthom reads라고 한다. 즉 이전에는 존재하지 않으니 읽을 수 없었지만 다른 트랜잭션이 일으킨 변화로 사용하던 트랜잭션 하에서는 존재하지 않았던 읽기가 나타난 것이다.
	* 실제로 아직 존재하지 않기에 일반적인 락 기반으로 해결하기도 힘들다.
	* 특정한 조건을 만족하는 범위에 락을 거는 술어 락(Predicate Lock)이 있다.
	* 술어 락은 특정 조건(술어)을 만족하는 모든 데이터에 대해 락을 걸 수 있는 메커니즘이다.[https://dl.acm.org/doi/pdf/10.1145/360363.360369]
	* 개별 레코드가 아닌 조건(술어)에 대해 락을 걸어 동시성을 제어한다.[https://www.geeksforgeeks.org/predicate-locking/]
* 잃어버린 업데이트 Lost updates는 동시에 실행되는 여러 트랜잭션이 같은 데이터를 수정할 때 발생하는 문제이다. 두 개  이상의 트랜잭션이 동시에 같은 데이터를 읽고 수정할 때 한 트랜잭션의 변경사항이 다른 트랜잭션에 의해 덮어쓰여 진다. 
	* 트랜잭션 A가 데이터를 읽고 수정한다. 아직 커밋하지 않았다. 트랜잭션 B가 같은 데이터를 읽고 수정한 후 커밋한다. 이때 트랜잭션 A의 변경사항이 덮어쓰여진다.


#### 현재 실행 중인 트랜잭션의 고립 수준(Isolation level for inflight transaction)

* READ UNCOMMITTED: 고립성이 없다. 외부에서의 모든 변경 사항은 커밋되었는 지 여부에 상관없이 트랜잭션에 보인다.
	*  당연히 Dirty Read 현상이 발생할 수 있다.
	* 성능은 가장 좋겠지만 데이터의 일관성이 가장 낮다.
* READ COMMITTED: 커밋된 데이터만 읽을 수 있다.
	* 대부분의 데이터베이스 시스템의 기본 격리 수준이다.
	* 커밋된 데이터만 읽으니 Diry Read 현상을 방지한다.
	* 성질상 Non-repeatable Read를 방지할 수 없다.
* REPEATABLE READ: 트랜잭션 내에서 같은 쿼리를 여러 번 실행해도 항상 같은 결과를 보장한다.
	* 트랜잭션이 실행되는 동안 쿼리가 행을 읽을 때 해당 행이 변경되지 않음을 보장한다.
	* Non-repeatable Read를 방지한다.
	* Phantom Read 현상은 발생할 수 있다.
* SNAPSHOT: 각 쿼리는 트랜잭션이 시작한 시점까지 커밋된 변경사항만을 볼 수 있다.
	* 트랜잭션 내에서 읽은 데이터는 다른 동시 트랜잭션의 변경 사항을 반영하지 않는다.
	* 데이터를 읽을 때 잠금을 사용하지 않는다.
	* 이로 인해 읽기 작업이 쓰기 작업을 차단하지 않고, 그 반대도 마찬가지다.
	* 변경된 데이터의 이전 버전을 tempdb에 저장한다.
	* 모든 읽기 현상을 제거한다.
	* 다른 격리 수준으로 시작된 트랜잭션은 SNAPSHOT으로 변경할 수 없다. 
	* SNAPSHOT으로 시작된 트랜잭션은 다른 격리 수준으로 변경할 수 없다.
* SERIALIZABLE
	* 가장 높은 격리 수준이다.
	* 완벽한 읽기 일관성을 제공한다.
	* 동시성이 가장 낮고 성능 오버헤드가 가장 크다

#### 데이터베이스의 고립성 구현 Databse implementain of isolation

* 각 데이터베이스 관리 시스템 마다 고립성 레벨의 구현이 다르다.
* 비관적Pessimistic 잠금 방식: 행 수준 잠금, 테이블 잠금, 페이지 잠금등은 잃어버린 업데이트를 방지한다. 다만 잠금을 사용하는 만큼 다른 트랜잭셔은 대기를 해야하고 이는 비용 상승을 유발한다.
* 낙관적Optimistic: 잠금이 없다. 대기중인 트랜잭션이 없다. 만약 트랜잭션 도중에 무언가 변경이 가해지면 트랜잭션을 실패시키고 다시 시도한다.
* 반복 가능한 읽기 잠금Repeatabe read: 읽고 있는 행을 잠금시킨다. 읽는 행이 매우 많을 경우 Postgresql은 스냅샵을 만들어 제공한다. 이 이유로 유령 읽기가 일어나지 않는다.
* Serializable: 매우 높은 동시성 제어가 필요할 때 사용한다. 트랜잭션에 순서를 지정한다.


### 일관성 Consistency

* 일관성은 두 가지로 볼 수 있다.
* 하나는 데이터의 자체의 일관성 즉 실제 디스크에 저장되어 있는 정보와 데이터 모델이 일치하는 지의 여부
* 읽기의 일관성, 이는 여러 인스턴스가 연결된 시점에서 동기화 되지 않았을 때를 떠올리면 알 수 있다.

#### 일관된 데이터

* 사용자의 의해 정의된다. 여기서 사용자란 데이터 모델과 데이터베이스 구축하는 사람을 말한다.
* 참조 무결성Referential intergrity(외래키 관련
	* 가령 사진 테이블이 있고 좋아요 칼럼이 2라고 해보자
	* 이 사진을 좋아요 한 회원과 사진의 정보를 갖고 있는 테이블이 있다.
	* 이 테이블에서 사진 테이블의 칼럼과 외래 관계를 맺고 있는 칼럼의 수도 2여야 한다. 
	* 만약 이 둘이 일치하지 않는다면 데이터의 일관성이 사라지고 참조 무결성이 사라진 것이다.
	* 또는 회원-사진 테이블에 값이 있다고 나왔지만 사진 테이블에 해당 외래키에 맞는 값이 없을 경우도 마찬가지로 일관성이 사라지고 무결성이 사라진 것이다. 
* 원자성
* 고립성

#### 일관된 읽기

* 이는 하나의 질문에서 시작한다. 
* 하나의 트랜잭션에세 새로운 변경을 커밋했을 때 새로운 트랜잭션에서 즉시 그 변경을 볼 수 있는가?
* 가령 주 데이터베이스가 있고 복사된 데이터베이스가 있고 변경으로 주 데이터베이스는 바뀌었지만 아직 복사본에 동기화가 되지 않아 읽기에는 반영이 되지 않았을 때가 있다.
* 이는 일관된 읽기가 사라진 것이다.
* 이런 문제로 최종 일관성 Eventual consistency 라는 개념이 생겼다. 
	* 이는 일관성을 맞추는 추가 작업을 하면 최종적으로 일관성이 생긴다는 말이다.

#### 지속성 Durability

* 커밋된 트랜잭션이 만든 변경은 반드시 비휘발적이고 지속적인 저장소에 저장되어야 한다
* 시스템 장애, 정전, 충돌 등에도 불구하고 영구적으로 유지되어야 한다.
* 이는 당연해 보지만 실제로는 그렇지 않다. 
* 디스크에 저장하는 건 느린 일이고 이 때문에 데이터베이스 시스템 중 일부는 스냅샵을 찍어 메모리에 저장하고 디스크에 저장되었다고 하기도 한다. 
* 지속성의 기술들
	*  WAL(Write ahead log): 모든 변경 사항은 먼저 즉시 여기에 기록된다.
		* 많은 데이터를 디스크에 쓰는 건 비싸다(인덱스들, 데이터 파일들, 행과 열 등등의 업데이트)
		* DBMS는 변경 버전을 압축해서 WAL로 알려진 로그 세그먼트만을 기록한다.
		* WAL이 안전하게 디스크에 저장된 후에야 실제 데이터베이스 파일이 수정된다.
	* Asynchronous snapshot: 비동기 스냅샷 또는 동기 스냅샷으로 특정 시점의 데이터 상태를 캡쳐ㅎ 한다.
	* AOF(Append Only File)


#### OS 캐시

* 실제로 OS에 쓰기 요청을 보내면 대개 OS 캐시로 보낸다.
* 이는 실제로 디스크에 쓰지 않고 OS 메모리 캐시에 씀을 의미한다.
* 캐시에 저장했지만 마치 디스크에 저장한듯 응답하기 때문에 OS가 장애가 일어나 컴퓨터가 재시작한다면 데이터를 잃는다.
* 때문에 지속성 보장을 위해 OS에 강제로 쓰기를 명령해야 한다.
* 이를 Fsync 라고한다. 
* 많은 쓰기를 한 번에 디스크에 보내는 건 느린 행위이기에 당연히 성능 저하가 생긴다.