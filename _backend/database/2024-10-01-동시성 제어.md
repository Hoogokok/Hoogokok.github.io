---
layout: post
title: 동시성 제어
category: database
date: 2024-10-01
tags: database
---
## 공유 락과 배타 락

배타 락은 쓰기를 위해 필요하다. 공유 락은 읽기를 사용한다. 공유 락은 말 그대로 락을 공유할 수 있다. 누군가 공유 락을 갖고 있다면 배타 락은 획득하지 못한다. 반대로 배타 락을 누가 획득했다면 다른 사람은 배타 락과 공유 락을 획득하지 못한다. 

이유는 일관성을 위해서이다. 간단하게 생각하면 읽기는 변화를 시키지 않지만 쓰기는 변화를 일으킨다. 쓰기와 읽기를 동시에 한다면 읽기를 시도하는 사람은 과거의 정보를 보고 있을 수 있다.


## 데드락

데드락은 두 개의 프로세스 또는 클라이언트가 하나의 리소스를 두고 경쟁하는 경우에 발생한다. 각각의 클라이언트가 특정 리소스의 잠금이 해제되기를 기다리는 상황을 말한다. 가령 데이터베이스에서 하나의 테이블에서 두 개의 클라이언트가 트랜잭션을 얻고 insert 쿼리를  보냈다고 가정해보자.

한 클라이언트가 쿼리를 작성했지만 아직 커밋은 하지 않았다. 이때 다른 클라이언트가 중복이 허용되지 않는 값을 중복되게 insert 쿼리르 작성한다면 어떻게 될까? 

바로 이때 늦게 도착한 클라이언트는 데드락 경고를 보게 된다. 중복이 허용되지 않는 하나의 리소스를 두고 두 클라이언트가 경쟁을 한 것이다.


## 2단계 락

2단계 락은 데이터베이스 락을 획득하고 단계별로 해제하는 개념. 하나의 좌석을 두 고객이 밀리초 차이로 예약을 시도해 생기는 이중 예약을 방지하는 데  쓸 수 있다. 두 클라이언트가 하나의 좌석 예약을 시도한다.  

```sql
클라이언트 1
select * from seats where id = 15 for update;
```

```sql
클라이언트 2
select * from seats where id = 15 for update;
```

for update는 사용하면 클라이언트는 배타 락을 얻게 된다. 이때 클라이언트2는 대기를 한다. 위에서 설명했지만 배타 락은 한 리소스 당 하나만 얻을 수 있다. 그후 첫번째 클라이언트가 아무 예약도 없다는 사실을 확인하고 다음과 같은 쿼리를 작성한다.

```sql
update seats set isbooked = 1, name = '비지' where id = 15
```

그후 commit 명령어를 사용하거나 rollback 명령어를 사용하면 배타 락이 풀린다. 커밋을 했을 경우 클라이언트2는 멈춤이 풀리고 isbooked와 name이 변경되어 이미 예약했다는 사실을 알 수 있다.


#### 오프셋을 이용한 SQL 페이징은 왜 느릴까?

sql 쿼리로 페이지네이션 조회를 할 때 offset를 사용하지 않기를 권장하는 이유는 매우 간단하다. 
```sql
select title from news order by id desc offset 1000000 limit 10
```

다음 쿼리 문을 보자. offset을 1000000로 지정하면 데이터베이스는 1000010개 행을 불러온 후 그중 1000000 부터 1000010을 찾는 식으로 동작한다. 우리가 실제로 필요한 행 보다 훨씬 많이 불러온 후 나머지를 버리는 방식으로 동작하기에 offset 크기가 커질 수록 쿼리의 응답은 느려진다.

그러면 이 문제를 어떻게 해결할 수 있을까? id에 인덱스가 걸려 있다고 가정하자 

```sql
select title from news where id < 10099993(원하는 아이디 값) order by id desc limit 10
```
10099993은 id의 가장 마지막 값이라고 해보자. 이런 식으로 적용하면 인덱스 스캔을 이용해 데이터베이스는 id 보다 작은 행을 딱 10개만 가져온다.


#### 커넥션 풀

매번 데이터베이스와 새로 연결을 하고 연결을 끊는 방식이 아니라, 이미 연결된 걸 재사용하는 방식이다. 매번 데이터베이스와 TCP 연결을 하고 끊는 방식은 비용이 비싸고 느리다.
